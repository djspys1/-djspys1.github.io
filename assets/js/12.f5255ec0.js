(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{331:function(n,e,r){"use strict";r.r(e);var s=r(33),o=Object(s.a)({},(function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"ssh2实现自动化上传"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ssh2实现自动化上传"}},[n._v("#")]),n._v(" ssh2实现自动化上传")]),n._v(" "),r("p",[n._v("如今，前后端分离越来越流行，前端项目的各种打包部署工具也越来越多，可以通过jenkins,pipline等等一键部署。本篇记录使用node的ssh2来进行自动化打包上传")]),n._v(" "),r("p",[n._v("首先需要明白自动化上传的思路，本篇以本人的导航项目"),r("a",{attrs:{href:"http://www.djspys.com",target:"_blank",rel:"noopener noreferrer"}},[n._v("个人导航"),r("OutboundLink")],1),n._v("为蓝本。")]),n._v(" "),r("p",[n._v("该项目通过vue-cli来生成，默认使用的webpack打包，按照以前的部署方法，应该是"),r("code",[n._v("npm run build")]),n._v("进行打包，然后手动上传至服务器，现在使用ssh2来进行自动化上传。")]),n._v(" "),r("ul",[r("li",[r("p",[n._v("首先第一步，是下载相应的模块，必须的是ssh2模块"),r("a",{attrs:{href:"https://www.npmjs.com/package/ssh2",target:"_blank",rel:"noopener noreferrer"}},[n._v("ssh2地址"),r("OutboundLink")],1),n._v(" "),r("code",[n._v("npm install ssh2")]),n._v("\n这是官方的，详细使用查看相关文档，注意的是，个人使用还是加上dev参数比较好")])]),n._v(" "),r("li",[r("p",[n._v("ssh2是连接远程服务器的，配置一些基本的服务器配置,我是在"),r("code",[n._v("config/prod.env.js")]),n._v("进行了配置，包括了服务器名称，账号，密码，项目名称，路径等等，这些配置都不一定非要提取出来，可以自由配置设置通过shell交互进行输入。")])])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("'use strict'\n// const DEFAULT_SERVER = '\"localhost:8080\"'\nconst REMOTE_SERVER = '0.0.0.0'\nconst DEFAULT_HOST = {host: REMOTE_SERVER, user: '******', password: '******', key: '', name: 'navigation', path: '/opt/lampp/htdocs'}\n\nmodule.exports = {\n  NODE_ENV: '\"production\"',\n  REMOTE_HOST: REMOTE_SERVER,\n  DEFAULT_HOST: DEFAULT_HOST,\n}\n")])])]),r("ul",[r("li",[r("p",[n._v("webpack打包后一般为一个dist文件夹，里面包含了一个static文件夹和index.html文件，这里再使用压缩工具压缩为zip文件，减少上传数量，我使用的是"),r("a",{attrs:{href:"https://www.npmjs.com/package/archiver",target:"_blank",rel:"noopener noreferrer"}},[n._v("archiver"),r("OutboundLink")],1),n._v("，这里仍加上dev参数")])]),n._v(" "),r("li",[r("p",[n._v("现在我的目标是一行命令进行打包上传，在package.json文件里配置相应的命令")])])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('...\n  "scripts": {\n    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",\n    "start": "npm run dev",\n    "lint": "eslint --ext .js,.vue src",\n    "build": "node build/build.js",\n    "publish": "node build/build.js -p"\n  },\n...\n')])])]),r("p",[n._v("我加了一行publish，他和build相似，区别就是多了一个默认参数"),r("code",[n._v("-p")]),n._v("， 我的想法是通过监听这个参数，来判断是只进行打包还是打包上传。")]),n._v(" "),r("ul",[r("li",[n._v("修改buiild/build.js文件以便能实现上一步所说的监听")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("'use strict'\nrequire('./check-versions')()\n\nprocess.env.NODE_ENV = 'production'\nconst program = require('commander')\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n\nconst spinner = ora('building for production...')\nspinner.start()\nprogram\n  .version('0.0.1')\n  .option('-p, --publish', 'Publish Remote')\n  .parse(process.argv)\n\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n  if (err) throw err\n  webpack(webpackConfig, (err, stats) => {\n    spinner.stop()\n    if (err) throw err\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.\n      chunks: false,\n      chunkModules: false\n    }) + '\\n\\n')\n\n    if (stats.hasErrors()) {\n      console.log(chalk.red('  Build failed with errors.\\n'))\n      process.exit(1)\n    }\n\n    console.log(chalk.cyan('  Build complete.\\n'))\n    console.log(chalk.yellow(\n      '  Tip: built files are meant to be served over an HTTP server.\\n' +\n      '  Opening index.html over file:// won\\'t work.\\n'\n    ))\n    if (program.publish) {\n      require('../publish/publish-zip')()\n    }\n  })\n})\n")])])]),r("p",[n._v("这一步引入了一个"),r("code",[n._v("commander")]),n._v("，并在最后对"),r("code",[n._v("program.publish")]),n._v("进行了判断，若存在则引入"),r("code",[n._v("publish/publish-zip")]),n._v("文件。到这一步为止，如果输入了"),r("code",[n._v("npm run publish")]),n._v("，这会完成相应的打包工作，并且引入了"),r("code",[n._v("publish/publish-zip")]),n._v("文件。")]),n._v(" "),r("ul",[r("li",[n._v("引入的文件的主要工作是进行压缩，方法如下")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const fs = require('fs')\nconst archiver = require('archiver')\nconst env = require('../config/prod.env')\n// const chalk = require('chalk')\n\nmodule.exports = function () {\n//   console.log(chalk.cyan('  Zip files.\\n'))\n//   console.time('key')\n  var output = fs.createWriteStream(`publish/${env.DEFAULT_HOST.name}.zip`)\n  var archive = archiver('zip')\n\n  output.on('close', function () {\n    // console.log(chalk.cyan('  Zip files.\\n'))\n    // console.timeEnd('key')\n    console.log('compress completed...ready upload')\n    require('./publish')()\n  })\n\n  output.on('end', function () {\n  })\n\n  archive.on('error', function (err) {\n    throw err\n  })\n\n  archive.pipe(output)\n  archive.glob('./dist' + '/**')\n  archive.finalize()\n}\n\n")])])]),r("p",[n._v("该文件的主要作用就是，将打包后的文件进行压缩，压缩名为配置中的navigation.zip,压缩完成后引入"),r("code",[n._v("publish.js")]),n._v("文件")]),n._v(" "),r("ul",[r("li",[n._v("接下来就是上传至服务器，代码如下")])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const env = require('../config/prod.env')\nconst chalk = require('chalk')\nvar Client = require('ssh2').Client\nvar conn = new Client()\nvar fs = require('fs')\n\nconst user = {\n  host: env.DEFAULT_HOST.host,\n  port: 22,\n  username: env.DEFAULT_HOST.user,\n  password: env.DEFAULT_HOST.password\n}\n\n/**\n * 1.进入目录\n * 2.删除旧的备份项目\n * 3.将原项目名称加上bak标志为备份文件\n * 4.解压缩上传的zip文件并将名称改为项目名称\n * 5.删除zip文件\n * 6.退出\n * @type {string[]}\n */\nconst uploadShellList = [\n  `cd ${env.DEFAULT_HOST.path}\\n`,\n  `rm -rf ${env.DEFAULT_HOST.name}.bak\\n`,\n  `mv ${env.DEFAULT_HOST.name} ${env.DEFAULT_HOST.name}.bak\\n`,\n  `unzip ${env.DEFAULT_HOST.name}.zip\\n`,\n  `mv dist ${env.DEFAULT_HOST.name}\\n`,\n  `rm -rf ${env.DEFAULT_HOST.name}.zip\\n`,\n  `exit\\n`\n]\nconst params = {file: `./publish/${env.DEFAULT_HOST.name}.zip`, target: `${env.DEFAULT_HOST.path}/${env.DEFAULT_HOST.name}.zip`}\n\n/**\n * 上传文件\n * @param conn\n * @param params\n * @constructor\n */\nfunction UploadFile (conn, params) {\n  const file = params.file\n  const target = params.target\n  if (!conn) {\n    return\n  }\n  conn.sftp(function (err, sftp) {\n    if (err) {\n      throw err\n    }\n    sftp.fastPut(file, target, {}, function (err, result) {\n      if (err) {\n        console.log(chalk.red(err.message))\n        throw err\n      }\n      Shell(conn)\n    })\n  })\n}\n\nfunction Ready () {\n  conn.on('ready', function () {\n    console.log('Client :: ready')\n    UploadFile(conn, params)\n  }).connect(user)\n}\n\n/**\n * 上传完成后服务器需要执行的内容\n * 删除本地压缩文件\n * @param conn\n * @constructor\n */\nfunction Shell (conn) {\n  conn.shell(function (err, stream) {\n    if (err) throw err\n    stream.on('close', function () {\n      console.log('Stream :: close')\n      conn.end()\n      fs.unlinkSync(`./publish/${env.DEFAULT_HOST.name}.zip`)\n    }).on('data', function (data) {\n      console.log('STDOUT: ' + data)\n    }).stderr.on('data', function (data) {\n      console.log('STDERR: ' + data)\n    })\n    stream.end(uploadShellList.join(''))\n  })\n}\n\nmodule.exports = function () {\n  try {\n    Ready()\n  } catch (err) {\n    console.log(err)\n  }\n}\n\n")])])]),r("p",[n._v("思路就是：链接服务器->调用uploadFile方法->调用Shell方法（命令自行调整，详情看注释）->删除本地压缩文件")]),n._v(" "),r("ul",[r("li",[n._v("至此，已经完成了自动化部署，可以愉快的使用"),r("code",[n._v("npm run publish")]),n._v("进行自动化的部署了")])]),n._v(" "),r("p",[n._v("注：")]),n._v(" "),r("ul",[r("li",[r("p",[n._v("使用sftp时，远程路径不加后缀会报错")])]),n._v(" "),r("li",[r("p",[n._v("Shell不能进行交互，可以换exec,使用shell可能会遇到的问题就是，假如服务器项目未删除，又对其进行了覆盖操作，他会提示是否覆盖，而你并不能在本地进行交互，结果就是卡在那。")])]),n._v(" "),r("li",[r("p",[n._v("假如不想把密码放在项目中，可以自行研究readline")])]),n._v(" "),r("li",[r("p",[n._v("密码不放在项目时publish文件代码")])])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const env = require('../config/prod.env')\nconst chalk = require('chalk')\nvar Client = require('ssh2').Client\nvar fs = require('fs')\nconst readline = require('readline')\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\n\n/**\n * 1.进入目录\n * 2.删除旧的备份项目\n * 3.将原项目名称加上bak标志为备份文件\n * 4.解压缩上传的zip文件并将名称改为项目名称\n * 5.删除zip文件\n * 6.退出\n * @type {string[]}\n */\nconst uploadShellList = [\n  `cd ${env.DEFAULT_HOST.path}\\n`,\n  `rm -rf ${env.DEFAULT_HOST.name}.bak\\n`,\n  `mv ${env.DEFAULT_HOST.name} ${env.DEFAULT_HOST.name}.bak\\n`,\n  `unzip ${env.DEFAULT_HOST.name}.zip\\n`,\n  `mv dist ${env.DEFAULT_HOST.name}\\n`,\n  `rm -rf ${env.DEFAULT_HOST.name}.zip\\n`,\n  `exit\\n`\n]\nconst params = {file: `./publish/${env.DEFAULT_HOST.name}.zip`, target: `${env.DEFAULT_HOST.path}/${env.DEFAULT_HOST.name}.zip`}\n\n/**\n * 上传文件\n * @param conn\n * @param params\n * @constructor\n */\nfunction UploadFile (conn, params) {\n  const file = params.file\n  const target = params.target\n  if (!conn) {\n    return\n  }\n  conn.sftp(function (err, sftp) {\n    if (err) {\n      throw err\n    }\n    sftp.fastPut(file, target, {}, function (err, result) {\n      if (err) {\n        console.log(chalk.red(err.message))\n        throw err\n      }\n      Shell(conn)\n    })\n  })\n}\n\nfunction Ready () {\n  var conn = new Client()\n  const user = {\n    host: env.DEFAULT_HOST.host,\n    port: 22,\n    username: env.DEFAULT_HOST.user,\n    password: env.DEFAULT_HOST.password\n  }\n  if (user.password) {\n    Publish(conn, user)\n  } else {\n    rl.question(chalk.green(`发布至服务器 ${env.DEFAULT_HOST.host} 请输入服务器密码:`), (answer) => {\n      // console.log(chalk.green(`发布至服务器 ${host.host} 请输入服务器密码:`))\n      if (answer !== null) {\n        user.password = answer.replace(/\\r\\n$/, '')\n        Publish(conn, user)\n      }\n    })\n  }\n}\n\nfunction Publish (conn, user) {\n  conn.on('ready', function () {\n    console.log('Client :: ready')\n    UploadFile(conn, params)\n  }).connect(user)\n}\n\n/**\n * 上传完成后服务器需要执行的内容\n * 删除本地压缩文件\n * @param conn\n * @constructor\n */\nfunction Shell (conn) {\n  conn.shell(function (err, stream) {\n    if (err) throw err\n    stream.on('close', function () {\n      console.log('Stream :: close')\n      conn.end()\n      fs.unlinkSync(`./publish/${env.DEFAULT_HOST.name}.zip`)\n    }).on('data', function (data) {\n      console.log('STDOUT: ' + data)\n    }).stderr.on('data', function (data) {\n      console.log('STDERR: ' + data)\n    })\n    stream.end(uploadShellList.join(''))\n  })\n}\n\nmodule.exports = function () {\n  try {\n    Ready()\n  } catch (err) {\n    console.log(err)\n  }\n}\n")])])]),r("p",[n._v("此时，在打包完成后，它会提示输入服务器密码：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("compress completed...ready upload\n发布至服务器 0.0.0.0 请输入服务器密码:\n")])])])])}),[],!1,null,null,null);e.default=o.exports}}]);